# .github/workflows/cobol_modernizer.yml

name: COBOL Modernization Orchestrator

# 步驟 2: 定義觸發條件
on:
  push:
    branches:
      - cobol-for-analysis # 當有程式碼推送到此分支時觸發

jobs:
  modernize:
    runs-on: ubuntu-latest # 使用最新的 Ubuntu 虛擬環境

    # 步驟 7: 設定人工審核環境
    environment: 
      name: Production Deployment # 借用"環境"功能來做人工審批
      url: https://slack.com # 審批按鈕會連結到這裡，可自訂

    steps:
      # 步驟 3: 取得程式碼
      - name: Checkout COBOL code
        uses: actions/checkout@v4

      # 步驟 4: 呼叫 Dify API 進行分析
      - name: Analyze with Dify and Generate Spec
        id: dify_analysis # 給這個步驟一個 ID，方便後續引用其輸出
        run: |
          # 找到最新的 COBOL 檔案 (可自行優化此邏輯)
          COBOL_FILE=$(ls *_cbl | head -n 1)
          echo "Analyzing file: $COBOL_FILE"

          # 使用 curl 呼叫 Dify API
          # 注意：這裡的 -d 內容需要根據您的 Dify 應用輸入來調整
          RESPONSE_JSON=$(curl -X POST "https://api.dify.ai/v1/workflows/run" \
            -H "Authorization: Bearer ${{ secrets.DIFY_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{
                  "inputs": {
                    "FILE_UPLOAD": "'$(cat $COBOL_FILE)'"
                    "path": "c:\\test"
                  },
                  "response_mode": "blocking",
                  "user": "github-actions-user"
                }')

          # 從 Dify 的回應中提取 OpenAPI Spec 內容
          SPEC_CONTENT=$(echo "$RESPONSE_JSON" | jq -r '.data.outputs.openapi_spec') # 假設 Dify 輸出欄位為 openapi_spec

          # 將 Spec 儲存為檔案，並將檔案路徑設為此步驟的輸出
          echo "$SPEC_CONTENT" > generated_spec.yaml
          echo "spec_path=generated_spec.yaml" >> $GITHUB_OUTPUT

      # 步驟 5: 發送通知到 Slack 等待審核
      - name: Send for Human Review
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": "COBOL 程式碼分析完成，請審核產生的規格文件。",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "來自 `${{ github.repository }}` 的現代化請求\n*程式碼*: `${{ github.event.head_commit.message }}`\n由 `${{ github.actor }}` 觸發"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "AI 產生的規格文件已準備好，等待您的批准後，將交由 Kiro 進行開發。\n請點擊 GitHub Actions 上的 'Review deployments' 按鈕進行審批。"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      # 步驟 6: 人工審批環節 (Workflow 會在此暫停)
      # 這個步驟是隱式的，由上面 job 層級的 `environment` 設定來實現。
      # 當 workflow 執行到這裡，指定的審核人會在 GitHub 上看到一個等待審批的請求。

      # 步驟 8: 審批通過後，呼叫 Kiro API
      - name: Convert with Kiro
        if: success() # 只有在審批通過後才執行
        id: kiro_conversion
        run: |
          SPEC_FILE_PATH=${{ steps.dify_analysis.outputs.spec_path }}
          echo "Starting Kiro conversion with spec: $SPEC_FILE_PATH"

          # 這裡示意性地呼叫 Kiro API
          # 實際的 API 端點和參數請參考 Kiro 文件
          curl -X POST "https://api.kiro.dev/v1/convert" \
            -H "Authorization: Bearer ${{ secrets.KIRO_API_KEY }}" \
            -F "spec=@$SPEC_FILE_PATH" \
            -F "target_language=java" \
            -F "framework=springboot" \
            -o modernized_code.zip
          
          echo "code_path=modernized_code.zip" >> $GITHUB_OUTPUT

      # 步驟 9: 交付成果 (建立 Pull Request)
      - name: Create Pull Request with Modernized Code
        if: success()
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "feat: Modernize COBOL with Kiro-generated Java code"
          title: "Automated Modernization: New Java Service"
          body: |
            This PR was automatically generated by the COBOL Modernization workflow.
            - Original COBOL analysis by Dify.
            - Specification approved by @${{ github.actor }}.
            - Java code generated by Kiro.
          branch: "feature/modernized-java-service"
          base: "main" # 您的主要開發分支
          # 注意：需要將 Kiro 產生的程式碼解壓縮到正確的位置
          # 這一步可能需要額外的 shell script 來處理
