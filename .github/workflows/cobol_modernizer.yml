# .github/workflows/cobol_modernizer.yml

name: COBOL Modernization Orchestrator

# 步驟 2: 定義觸發條件
on:
  push:
    branches:
      - cobol-for-analysis # 當有程式碼推送到此分支時觸發

jobs:
  modernize:
    runs-on: ubuntu-latest # 使用最新的 Ubuntu 虛擬環境

    # 步驟 7: 設定人工審核環境
    environment: 
      name: Production Deployment # 借用"環境"功能來做人工審批
      url: https://slack.com # 審批按鈕會連結到這裡，可自訂

    steps:
      # 步驟 3: 取得程式碼
      - name: Checkout COBOL code
        uses: actions/checkout@v4

      # 步驟 4: 呼叫 Dify API 進行分析 (已修正)
      - name: Analyze with Dify and Generate Spec
        id: dify_analysis # 給這個步驟一個 ID，方便後續引用其輸出
        run: |
          # 步驟 4.1: 使用 find 指令安全地找到目標檔案
          COBOL_FILE=$(find . -name "*_cbl.txt" -type f | head -n 1)

          # 如果找不到檔案，就印出錯誤訊息並終止工作流
          if [ -z "$COBOL_FILE" ]; then
            echo "::error::Could not find a file matching '*_cbl.txt'."
            exit 1
          fi
          echo "Found file to analyze: $COBOL_FILE"

          # 步驟 4.2: 【第一步】呼叫 Dify 檔案上傳 API
          # 這個指令會將您的檔案上傳，並取得一個 upload_file_id
          echo "Uploading file to Dify..."
          UPLOAD_RESPONSE_JSON=$(curl -s -X POST "https://api.dify.ai/v1/files/upload" \
            -H "Authorization: Bearer ${{ secrets.DIFY_API_KEY }}" \
            -F "user=github-actions-user" \
            -F "file=@$COBOL_FILE")
          
          # 從回應中提取 upload_file_id
          UPLOAD_FILE_ID=$(echo "$UPLOAD_RESPONSE_JSON" | jq -r '.id')

          # 如果上傳失敗或沒有取得 ID，就終止工作流
          if [ -z "$UPLOAD_FILE_ID" ] || [ "$UPLOAD_FILE_ID" == "null" ]; then
            echo "::error::Failed to upload file to Dify or get upload_file_id."
            echo "Dify Response: $UPLOAD_RESPONSE_JSON"
            exit 1
          fi
          echo "File uploaded successfully. Upload ID: $UPLOAD_FILE_ID"

          # 步驟 4.3: 【第二步】準備執行工作流的 JSON 資料
          # *** 請務必確認並修改以下兩個變數名稱 ***
          # 將 'file_input' 和 'path_input' 替換為您在 Dify 後台看到的真實變數名稱
          JSON_PAYLOAD=$(jq -n \
                            --arg upload_id "$UPLOAD_FILE_ID" \
                            --arg path_val "c:\\test" \
                            '{
                              "inputs": {
                                "file_input": [
                                  {
                                    "type": "document",
                                    "transfer_method": "local_file",
                                    "upload_file_id": $upload_id
                                  }
                                ],
                                "path_input": $path_val
                              },
                              "response_mode": "blocking",
                              "user": "github-actions-user"
                            }')
          
          echo "Executing workflow with payload..."
          # 步驟 4.4: 呼叫 Dify 執行工作流 API
          RESPONSE_JSON=$(curl -s -X POST "https://api.dify.ai/v1/workflows/run" \
                            -H "Authorization: Bearer ${{ secrets.DIFY_API_KEY }}" \
                            -H "Content-Type: application/json" \
                            -d "$JSON_PAYLOAD")

          # 步驟 4.5: 從 Dify 的回應中提取 OpenAPI Spec 內容
          SPEC_CONTENT=$(echo "$RESPONSE_JSON" | jq -r '.data.outputs.openapi_spec')

          # 步驟 4.6: 將 Spec 儲存為檔案，並將檔案路徑設為此步驟的輸出
          echo "$SPEC_CONTENT" > generated_spec.yaml
          echo "spec_path=generated_spec.yaml" >> $GITHUB_OUTPUT

      # 步驟 5: 發送通知到 Slack 等待審核
      - name: Send for Human Review
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": "COBOL 程式碼分析完成，請審核產生的規格文件。",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "來自 `${{ github.repository }}` 的現代化請求\n*程式碼*: `${{ github.event.head_commit.message }}`\n由 `${{ github.actor }}` 觸發"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "AI 產生的規格文件已準備好，等待您的批准後，將交由 Kiro 進行開發。\n請點擊 GitHub Actions 上的 'Review deployments' 按鈕進行審批。"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      # 步驟 6: 人工審批環節 (Workflow 會在此暫停)
      # 這個步驟是隱式的，由上面 job 層級的 `environment` 設定來實現。
      # 當 workflow 執行到這裡，指定的審核人會在 GitHub 上看到一個等待審批的請求。

      # 步驟 8: 審批通過後，呼叫 Kiro API
      - name: Convert with Kiro
        if: success() # 只有在審批通過後才執行
        id: kiro_conversion
        run: |
          SPEC_FILE_PATH=${{ steps.dify_analysis.outputs.spec_path }}
          echo "Starting Kiro conversion with spec: $SPEC_FILE_PATH"

          # 這裡示意性地呼叫 Kiro API
          # 實際的 API 端點和參數請參考 Kiro 文件
          curl -X POST "https://api.kiro.dev/v1/convert" \
            -H "Authorization: Bearer ${{ secrets.KIRO_API_KEY }}" \
            -F "spec=@$SPEC_FILE_PATH" \
            -F "target_language=java" \
            -F "framework=springboot" \
            -o modernized_code.zip
          
          echo "code_path=modernized_code.zip" >> $GITHUB_OUTPUT

      # 步驟 9: 交付成果 (建立 Pull Request)
      - name: Create Pull Request with Modernized Code
        if: success()
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "feat: Modernize COBOL with Kiro-generated Java code"
          title: "Automated Modernization: New Java Service"
          body: |
            This PR was automatically generated by the COBOL Modernization workflow.
            - Original COBOL analysis by Dify.
            - Specification approved by @${{ github.actor }}.
            - Java code generated by Kiro.
          branch: "feature/modernized-java-service"
          base: "main" # 您的主要開發分支
          # 注意：需要將 Kiro 產生的程式碼解壓縮到正確的位置
          # 這一步可能需要額外的 shell script 來處理
